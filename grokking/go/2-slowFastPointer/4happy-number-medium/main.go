// https://www.designgurus.io/course-play/grokking-the-coding-interview/doc/happy-number-medium

package main

import "fmt"

type Solution struct{}

func (s *Solution) find(num int) bool {
	fast, slow := num, num
	for {
		slow = digitSquare(slow)
		fast = digitSquare(digitSquare(fast))
		if slow == 1 || fast == 1 {
			return true
		}
		if slow == fast {
			return false
		}
	}
}

func digitSquare(num int) int {
	s := 0

	for num != 0 {
		r := num % 10
		s += r * r
		num = num / 10
	}
	return s
}

func main() {
	s := Solution{}
	fmt.Println(s.find(23))  // true
	fmt.Println(s.find(1))   // true
	fmt.Println(s.find(12))  // false
	fmt.Println(s.find(2))   // false
	fmt.Println(s.find(100)) // true
}

// Key Insight:
// We can use the slow and fast pointer technique to detect a cycle in the sequence of numbers generated by repeatedly replacing the number
// with the sum of the squares of its digits.
// If we reach 1, the number is happy. If we enter a cycle that does not include 1, the number is not happy.
// The slow pointer moves one step at a time (calculating the digit square once), while the fast pointer moves two steps at a time
// (calculating the digit square twice).
// If there is a cycle, the slow and fast pointers will eventually meet at the same number (not 1).
// If either pointer reaches 1, we can conclude that the number is happy.
