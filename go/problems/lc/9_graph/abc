func tarzanAlgo(V int, adj [][]int) int {
	scc := make([][]int, 0) // Initialize a slice to store strongly connected components
	edges := make([][]int, V) // Initialize a slice to store the edges of the graph

	// Build the adjacency list representation of the graph
	for i := 0; i < len(adj); i++ {
		edges[adj[i][0]] = append(edges[adj[i][0]], adj[i][1])
	}

	low := make([]int, V) // Initialize a slice to store the low values of each node
	dis := make([]int, V) // Initialize a slice to store the discovery time of each node

	// Initialize the low and discovery time arrays
	for i := 0; i < V; i++ {
		low[i] = -1
		dis[i] = -1
	}

	stack := make([]int, 0) // Initialize a stack to perform depth-first search
	inStack := make([]bool, V) // Initialize a boolean array to keep track of nodes in the stack

	var dfs func(int, int) int
	dfs = func(node int, timer int) int {
		if dis[node] == -1 { // If the node has not been visited yet
			low[node] = timer // Set the low and discovery time of the node
			dis[node] = timer
			inStack[node] = true // Mark the node as in the stack
			stack = append(stack, node) // Push the node to the stack

			// Perform depth-first search on the neighbors of the node
			for k, neighbor := range edges[node] {
				newLow := dfs(neighbor, timer+1+k) // Recursively call dfs on the neighbor
				if newLow < low[node] { // Update the low value of the node if necessary
					low[node] = newLow
				}
			}

			// If the node is the head of a strongly connected component
			if dis[node] == low[node] {
				sccNodes := []int{} // Initialize a slice to store the nodes in the SCC
				pop := stack[len(stack)-1] // Pop nodes from the stack until the current node is reached
				for pop != node {
					sccNodes = append(sccNodes, pop) // Add the popped node to the SCC
					inStack[pop] = false // Mark the popped node as not in the stack
					stack = stack[:len(stack)-1] // Remove the popped node from the stack
					pop = stack[len(stack)-1] // Get the next node to be popped
				}
				sccNodes = append(sccNodes, pop) // Add the current node to the SCC
				inStack[pop] = false // Mark the current node as not in the stack
				stack = stack[:len(stack)-1] // Remove the current node from the stack
				scc = append(scc, sccNodes) // Add the SCC to the list of SCCs
			}
			return low[node]
		}

		// If the node is in the stack, it is a back edge
		if inStack[node] {
			return dis[node]
		}

		// If the node is not in the stack, it is a cross edge
		return math.MaxInt
	}

	dfs(0, 0) // Perform depth-first search starting from node 0
	fmt.Println(scc) // Print the strongly connected components
	return len(scc) // Return the number of strongly connected components
}